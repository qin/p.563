/********************************************************************
ITU-T Draft Recommendation P.563
Version 1.0 - 23 March 2004
  
NOTICE 
  
The Single Ended Assessment Model P.563 algorithm and the copyright therein 
is the joint property of Psytechnics Limited, OPTICOM GmbH and SwissQual AG 
and is protected by UK, US and other patents, either applied for or registered. 
Permission is granted to use this source code solely for the purpose of 
evaluation of ITU-T recommendation P.563. 
Any other use of this software requires a licence, which may be obtained from: 
  
OPTICOM GmbH 
Am Weichselgarten 7, D- 91058 Erlangen, Germany 
Phone: +49 9131 691 160			Fax: +49 9131 691 325  
E-mail: info@opticom.de         www.3sqm.com  
  
Psytechnics Limited 
Fraser House, 23 Museum Street, Ipswich, IP1 1HN, UK 
Phone: +44 1 473 261 800		Fax: +44 1 473 261 880 
E-mail: info@psytechnics.com    www.psytechnics.com
  
SwissQual AG 
Gewerbestrasse 2 CH-4528 Zuchwil, Switzerland 
Phone: +41 32 685 08 30			Fax: +41 32 685 08 31   
E-mail: sales@swissqual.com     www.swissqual.com
  
Psytechnics, SwissQual or Opticom can provide licences and further information. 
  
Authors: 
      Ludovic Malfait ludovic.malfait@psytechnics.com 
      Roland Bitto rb@opticom.de 
      Pero Juric pero.juric@swissqual.com

********************************************************************/


#ifndef __HOSM_H
#define __HOSM_H

/* specific prototypes */ 
#include "generic_typedefs.h"
#include "vector_lib.h"
#include "interr_detect.h"

/* Local definitions */ 
#define BUFFSIZE						512
#define FRAME_OVERLAP					0.5		/* set to 0.5 for 50% frame_shift! eg. for bufer_len=256 shift=128 */
#define MAX_LEN_FOR_INTERPOLATION		0.06   	/* length of the signal interruption in seconds */
#define SILENCE							200		/* scanning test for active speech detection */
#define MAX_16BIT_VALUE					32767.0
#define MEAN_RMS_LEVEL			 		-26.0
#define ENERGY_WINDOWS					50		/* number of energy windows used for the noise floor detection */
#define MAX_BOUND_ABOVE_PEAK			10.0	/* max span in dB that the noise bound is allowed to be above noise peak */
#define MAX_BOUND_TO_PEAK				0.2		/* max bound to peak ratio */

#define LPC_ORDER_HOSM					21		/* LPC order for hosm module */

#define MAX_MOS_VALUE					4.5		/* maximum value for MOS */
#define NR_OF_RESULTS					12		/* Number of MOVs generated by HOSM (Higher Order Statistics Model) */

#define HISTOGRAM_RESET					101
#define HISTOGRAM_RUN  					102
#define MIN_SPEECH_ACTIV_RMS			100		

#define SQ_NO_ERRORS				 	 0	/* No errors  */
#define SQERR_UNKNOWN_ERROR				-1	/* Unknown error  */
#define SQERR_HISTOGRAM_NOT_CREATED		-5	/* Energy histogram not created */
#define SQERR_HISTOGRAM_NOT_EN_TRAYS	-6	/* Not enough binary trays in EnergyLevels Histogram */
#define SQERR_ALLOC_ERROR			 	-12	/* Memory allocation error */
#define SQERR_WRONG_LENGTH			 	-14	/* Length of an array wrong */

#define REFER_FILE						0


#ifndef MAX
#define  MAX(a,b)  (((a) > (b)) ? (a) : (b))
#endif

#ifndef MIN
#define  MIN(a,b)  (((a) < (b)) ? (a) : (b))
#endif



INT32 FindNoiseFloors ( typInputParameter *par, typChannel *channel);
INT32 CalcScalingParams ( typInputParameter *par, typChannel *channel);
INT32 hosm(typInputParameter *par, typChannel *ch, FLOAT *ITUResults);
INT32 initStructures(typInputParameter *par, typChannel *channel);
void  RemoveDCOffset(typChannel *channel, FLOAT *in, FLOAT *out, UINT32 file, UINT32 length);


/*------------------------------------------------------------------------------- */
/* sqft_NewFilter */
/* Create a new filter structure, and initialise it with the filter coefficients */
/* */
/* Input:	pdNumCoefB			ptr on vector with numerator coefficients */
/*								pdNumCoefB[0] = b0 */
/*			pdDenomCoefA		ptr on vector with denominator coefficients */
/*								pdDenomCoefA[0] = a0 */
/*			lNumCoefBLength		numbers of numerator coefficients */
/*			lDenomCoefBLength	number of denominator coefficients */
/* Return:	-					ptr on filter structure filled with coefficients */
/* Remark:	if pdDenomCoefA[0] is not equal to 1, sqft_NewFilter normalizes the filter */
/*			coefficients by pdDenomCoefA[0]. */
/* */
/*------------------------------------------------------------------------------- */

sctFilterInfo* sqft_NewFilter(FLOAT* pdNumCoefB,
							  FLOAT* pdDenomCoefA,
							  INT32 lNumCoefBLength,
							  INT32 lDenomCoefALength);


/*------------------------------------------------------------------------------- */
/* sqft_DeleteFilter */
/* Delete a filter structure created with sqft_NewFilter() */
/* */
/* Input:	psctFilter		ptr on filter structure */
/* Output:	psctFilter		ptr on filter structure, will be returned NULL */
/*							if function was successful */
/* Return:	- */
/* */
/*------------------------------------------------------------------------------- */

void sqft_DeleteFilter(sctFilterInfo** psctFilter);



/*------------------------------------------------------------------------------- */
/* sqft_CoefCopyScale (intern) */
/* Copies values in coefficient vectors in filter structure, */
/* if a0 is not equal to 1, sqft_CoefCopyScale normalizes the filter */
/* coefficients by a0. */
/* */
/* Input:	psctFilter		ptr on filter structure, structure will be */
/*							filled with filter coefficients */
/*			pdNumCoefB		ptr on vector with numerator coefficients */
/*							pdNumCoefB[0] = b0 */
/*			pdDenomCoefA	ptr on vector with denominator coefficients */
/*							pdDenomCoefA[0] = a0 */
/* */
/*------------------------------------------------------------------------------- */

INT16 sqft_CoefCopyScale(sctFilterInfo* psctFilter,
						 FLOAT* pdNumCoefB,
						 FLOAT* pdDenomCoefA);



/*------------------------------------------------------------------------------- */
/* sqft_Filter */
/* Filters a data sequence using a digital filter. The filter is a */
/* direct form II transposed implementation of the standard difference */
/* equation */
/* */
/* Inputs:	psctFilter		ptr on filter structure, created with */
/*							sqft_NewFilter */
/*			pdInData		ptr on input data vector */
/*			pdOutData		ptr on output data vector, */
/*							vector must have the same length as pdInData */
/*			lDataLength		length of pdInData and pdOutData vector */
/* Output:	pdOutData		pdOutData will be filled with filtered input data */
/* */
/*------------------------------------------------------------------------------- */

INT16 sqft_Filter(sctFilterInfo* psctFilter, FLOAT* pdInData,				  
				  FLOAT* pdOutData, INT32 lDataLength);


INT32  dCalcSpecPowDensFFT( FLOAT *pdA_InX, FLOAT *pdA_XSpecDens, INT32 iFrameLen);

INT32  Calc_DistrOfVector( FLOAT *pdA_Vector, INT32 lVecLen, FLOAT dMinValue, 
						  FLOAT dMaxValue, INT32 iLenDistrVec, FLOAT *pdA_DistrVec);

FLOAT  Calc_PercentilOfDistrVector( FLOAT dPercentil, FLOAT dMinValue, FLOAT dMaxValue, 
								   INT32 iLenDistrVec, FLOAT *pdA_DistrVec);

#endif
